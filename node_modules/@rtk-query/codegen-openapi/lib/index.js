"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConfig = exports.generateEndpoints = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const utils_1 = require("./utils");
async function generateEndpoints(options) {
    const schemaLocation = options.schemaFile;
    const schemaAbsPath = (0, utils_1.isValidUrl)(options.schemaFile)
        ? options.schemaFile
        : path_1.default.resolve(process.cwd(), schemaLocation);
    const sourceCode = await enforceOazapftsTsVersion(() => {
        const { generateApi } = require('./generate');
        return generateApi(schemaAbsPath, options);
    });
    const outputFile = options.outputFile;
    if (outputFile) {
        fs_1.default.writeFileSync(path_1.default.resolve(process.cwd(), outputFile), await (0, utils_1.prettify)(outputFile, sourceCode));
    }
    else {
        return await (0, utils_1.prettify)(null, sourceCode);
    }
}
exports.generateEndpoints = generateEndpoints;
function parseConfig(fullConfig) {
    const outFiles = [];
    if ('outputFiles' in fullConfig) {
        const { outputFiles, ...commonConfig } = fullConfig;
        for (const [outputFile, specificConfig] of Object.entries(outputFiles)) {
            outFiles.push({
                ...commonConfig,
                ...specificConfig,
                outputFile,
            });
        }
    }
    else {
        outFiles.push(fullConfig);
    }
    return outFiles;
}
exports.parseConfig = parseConfig;
/**
 * Enforces `oazapfts` to use the same TypeScript version as this module itself uses.
 * That should prevent enums from running out of sync if both libraries use different TS versions.
 */
function enforceOazapftsTsVersion(cb) {
    const ozTsPath = require.resolve('typescript', { paths: [require.resolve('oazapfts')] });
    const tsPath = require.resolve('typescript');
    const originalEntry = require.cache[ozTsPath];
    try {
        require.cache[ozTsPath] = require.cache[tsPath];
        return cb();
    }
    finally {
        if (originalEntry) {
            require.cache[ozTsPath] = originalEntry;
        }
        else {
            delete require.cache[ozTsPath];
        }
    }
}
//# sourceMappingURL=index.js.map