"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateApi = exports.getOverrides = void 0;
const path = __importStar(require("path"));
const generate_1 = __importStar(require("oazapfts/lib/codegen/generate"));
const utils_1 = require("./utils");
const tscodegen_1 = require("oazapfts/lib/codegen/tscodegen");
const codegen_1 = require("./codegen");
const lodash_1 = require("lodash");
const factory_1 = require("./utils/factory");
const react_hooks_1 = require("./generators/react-hooks");
const typescript_1 = __importDefault(require("typescript"));
const generatedApiName = 'injectedRtkApi';
function defaultIsDataResponse(code) {
    const parsedCode = Number(code);
    return !Number.isNaN(parsedCode) && parsedCode >= 200 && parsedCode < 300;
}
function getOperationName({ verb, path, operation }) {
    return (0, generate_1.getOperationName)(verb, path, operation.operationId);
}
function getTags({ verb, pathItem }) {
    var _a;
    return verb ? ((_a = pathItem[verb]) === null || _a === void 0 ? void 0 : _a.tags) || [] : [];
}
function patternMatches(pattern) {
    const filters = Array.isArray(pattern) ? pattern : [pattern];
    return function matcher(operationName) {
        if (!pattern)
            return true;
        return filters.some((filter) => typeof filter === 'string' ? filter === operationName : filter === null || filter === void 0 ? void 0 : filter.test(operationName));
    };
}
function operationMatches(pattern) {
    const checkMatch = typeof pattern === 'function' ? pattern : patternMatches(pattern);
    return function matcher(operationDefinition) {
        if (!pattern)
            return true;
        const operationName = getOperationName(operationDefinition);
        return checkMatch(operationName, operationDefinition);
    };
}
function withQueryComment(node, def, hasTrailingNewLine) {
    const comment = def.origin === 'param' ? def.param.description : def.body.description;
    if (comment) {
        return typescript_1.default.addSyntheticLeadingComment(node, typescript_1.default.SyntaxKind.MultiLineCommentTrivia, `* ${comment} `, hasTrailingNewLine);
    }
    return node;
}
function getOverrides(operation, endpointOverrides) {
    return endpointOverrides === null || endpointOverrides === void 0 ? void 0 : endpointOverrides.find((override) => operationMatches(override.pattern)(operation));
}
exports.getOverrides = getOverrides;
async function generateApi(spec, { apiFile, apiImport = 'api', exportName = 'enhancedApi', argSuffix = 'ApiArg', responseSuffix = 'ApiResponse', hooks = false, tag = false, outputFile, isDataResponse = defaultIsDataResponse, filterEndpoints, endpointOverrides, unionUndefined, flattenArg = false, useEnumType = false, mergeReadWriteOnly = false, }) {
    var _a;
    const v3Doc = await (0, utils_1.getV3Doc)(spec);
    const apiGen = new generate_1.default(v3Doc, {
        unionUndefined,
        useEnumType,
        mergeReadWriteOnly,
    });
    // temporary workaround for https://github.com/oazapfts/oazapfts/issues/491
    if ((_a = apiGen.spec.components) === null || _a === void 0 ? void 0 : _a.schemas) {
        apiGen.preprocessComponents(apiGen.spec.components.schemas);
    }
    const operationDefinitions = (0, utils_1.getOperationDefinitions)(v3Doc).filter(operationMatches(filterEndpoints));
    const resultFile = typescript_1.default.createSourceFile('someFileName.ts', '', typescript_1.default.ScriptTarget.Latest, 
    /*setParentNodes*/ false, typescript_1.default.ScriptKind.TS);
    const printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed });
    const interfaces = {};
    function registerInterface(declaration) {
        const name = declaration.name.escapedText.toString();
        if (name in interfaces) {
            throw new Error(`interface/type alias ${name} already registered`);
        }
        interfaces[name] = declaration;
        return declaration;
    }
    if (outputFile) {
        outputFile = path.resolve(process.cwd(), outputFile);
        if (apiFile.startsWith('.')) {
            apiFile = path.relative(path.dirname(outputFile), apiFile);
            apiFile = apiFile.replace(/\\/g, '/');
            if (!apiFile.startsWith('.'))
                apiFile = './' + apiFile;
        }
    }
    apiFile = apiFile.replace(/\.[jt]sx?$/, '');
    return printer.printNode(typescript_1.default.EmitHint.Unspecified, factory_1.factory.createSourceFile([
        (0, codegen_1.generateImportNode)(apiFile, { [apiImport]: 'api' }),
        ...(tag ? [(0, codegen_1.generateTagTypes)({ addTagTypes: extractAllTagTypes({ operationDefinitions }) })] : []),
        (0, codegen_1.generateCreateApiCall)({
            tag,
            endpointDefinitions: factory_1.factory.createObjectLiteralExpression(operationDefinitions.map((operationDefinition) => generateEndpoint({
                operationDefinition,
                overrides: getOverrides(operationDefinition, endpointOverrides),
            })), true),
        }),
        factory_1.factory.createExportDeclaration(undefined, false, factory_1.factory.createNamedExports([
            factory_1.factory.createExportSpecifier(factory_1.factory.createIdentifier(generatedApiName), factory_1.factory.createIdentifier(exportName)),
        ]), undefined),
        ...Object.values(interfaces),
        ...apiGen.aliases,
        ...apiGen.enumAliases,
        ...(hooks
            ? [
                (0, react_hooks_1.generateReactHooks)({
                    exportName: generatedApiName,
                    operationDefinitions,
                    endpointOverrides,
                    config: hooks,
                }),
            ]
            : []),
    ], factory_1.factory.createToken(typescript_1.default.SyntaxKind.EndOfFileToken), typescript_1.default.NodeFlags.None), resultFile);
    function extractAllTagTypes({ operationDefinitions }) {
        let allTagTypes = new Set();
        for (const operationDefinition of operationDefinitions) {
            const { verb, pathItem } = operationDefinition;
            for (const tag of getTags({ verb, pathItem })) {
                allTagTypes.add(tag);
            }
        }
        return [...allTagTypes];
    }
    function generateEndpoint({ operationDefinition, overrides, }) {
        const { verb, path, pathItem, operation, operation: { responses, requestBody }, } = operationDefinition;
        const operationName = getOperationName({ verb, path, operation });
        const tags = tag ? getTags({ verb, pathItem }) : [];
        const isQuery = (0, utils_1.isQuery)(verb, overrides);
        const returnsJson = apiGen.getResponseType(responses) === 'json';
        let ResponseType = factory_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.UnknownKeyword);
        if (returnsJson) {
            const returnTypes = Object.entries(responses || {})
                .map(([code, response]) => [
                code,
                apiGen.resolve(response),
                apiGen.getTypeFromResponse(response, 'readOnly') ||
                    factory_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.UndefinedKeyword),
            ])
                .filter(([status, response]) => isDataResponse(status, apiGen.resolve(response), responses || {}))
                .map(([code, response, type]) => typescript_1.default.addSyntheticLeadingComment({ ...type }, typescript_1.default.SyntaxKind.MultiLineCommentTrivia, `* status ${code} ${response.description} `, false))
                .filter((type) => type !== tscodegen_1.keywordType.void);
            if (returnTypes.length > 0) {
                ResponseType = factory_1.factory.createUnionTypeNode(returnTypes);
            }
        }
        const ResponseTypeName = factory_1.factory.createTypeReferenceNode(registerInterface(factory_1.factory.createTypeAliasDeclaration([factory_1.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], (0, utils_1.capitalize)(operationName + responseSuffix), undefined, ResponseType)).name);
        const parameters = (0, generate_1.supportDeepObjects)([
            ...apiGen.resolveArray(pathItem.parameters),
            ...apiGen.resolveArray(operation.parameters),
        ]);
        const allNames = parameters.map((p) => p.name);
        const queryArg = {};
        function generateName(name, potentialPrefix) {
            const isPureSnakeCase = /^[a-zA-Z][a-zA-Z0-9_]*$/.test(name);
            // prefix with `query`, `path` or `body` if there are multiple paramters with the same name
            const hasNamingConflict = allNames.filter((n) => n === name).length > 1;
            if (hasNamingConflict) {
                name = `${potentialPrefix}_${name}`;
            }
            // convert to camelCase if the name is pure snake_case and there are no naming conflicts
            const camelCaseName = (0, lodash_1.camelCase)(name);
            if (isPureSnakeCase && !allNames.includes(camelCaseName)) {
                name = camelCaseName;
            }
            // if there are still any naming conflicts, prepend with underscore
            while (name in queryArg) {
                name = '_' + name;
            }
            return name;
        }
        for (const param of parameters) {
            const name = generateName(param.name, param.in);
            queryArg[name] = {
                origin: 'param',
                name,
                originalName: param.name,
                type: apiGen.getTypeFromSchema((0, generate_1.isReference)(param) ? param : param.schema, undefined, 'writeOnly'),
                required: param.required,
                param,
            };
        }
        if (requestBody) {
            const body = apiGen.resolve(requestBody);
            const schema = apiGen.getSchemaFromContent(body.content);
            const type = apiGen.getTypeFromSchema(schema);
            const schemaName = (0, lodash_1.camelCase)(type.name || (0, generate_1.getReferenceName)(schema) || ("title" in schema && schema.title) || 'body');
            const name = generateName(schemaName in queryArg ? 'body' : schemaName, 'body');
            queryArg[name] = {
                origin: 'body',
                name,
                originalName: schemaName,
                type: apiGen.getTypeFromSchema(schema, undefined, 'writeOnly'),
                required: true,
                body,
            };
        }
        const propertyName = (name) => {
            if (typeof name === 'string') {
                return (0, tscodegen_1.isValidIdentifier)(name) ? factory_1.factory.createIdentifier(name) : factory_1.factory.createStringLiteral(name);
            }
            return name;
        };
        const queryArgValues = Object.values(queryArg);
        const isFlatArg = flattenArg && queryArgValues.length === 1;
        const QueryArg = factory_1.factory.createTypeReferenceNode(registerInterface(factory_1.factory.createTypeAliasDeclaration([factory_1.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], (0, utils_1.capitalize)(operationName + argSuffix), undefined, queryArgValues.length > 0
            ? isFlatArg
                ? withQueryComment({ ...queryArgValues[0].type }, queryArgValues[0], false)
                : factory_1.factory.createTypeLiteralNode(queryArgValues.map((def) => withQueryComment(factory_1.factory.createPropertySignature(undefined, propertyName(def.name), (0, tscodegen_1.createQuestionToken)(!def.required), def.type), def, true)))
            : factory_1.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.VoidKeyword))).name);
        return (0, codegen_1.generateEndpointDefinition)({
            operationName,
            type: isQuery ? 'query' : 'mutation',
            Response: ResponseTypeName,
            QueryArg,
            queryFn: generateQueryFn({ operationDefinition, queryArg, isQuery, isFlatArg }),
            extraEndpointsProps: isQuery
                ? generateQueryEndpointProps({ operationDefinition })
                : generateMutationEndpointProps({ operationDefinition }),
            tags,
        });
    }
    function generateQueryFn({ operationDefinition, queryArg, isFlatArg, isQuery, }) {
        const { path, verb } = operationDefinition;
        const bodyParameter = Object.values(queryArg).find((def) => def.origin === 'body');
        const rootObject = factory_1.factory.createIdentifier('queryArg');
        function pickParams(paramIn) {
            return Object.values(queryArg).filter((def) => def.origin === 'param' && def.param.in === paramIn);
        }
        function createObjectLiteralProperty(parameters, propertyName) {
            return parameters.length === 0
                ? undefined
                : factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier(propertyName), factory_1.factory.createObjectLiteralExpression(parameters.map((param) => (0, tscodegen_1.createPropertyAssignment)(param.originalName, isFlatArg ? rootObject : accessProperty(rootObject, param.name)), true)));
        }
        return factory_1.factory.createArrowFunction(undefined, undefined, Object.keys(queryArg).length
            ? [factory_1.factory.createParameterDeclaration(undefined, undefined, rootObject, undefined, undefined, undefined)]
            : [], undefined, factory_1.factory.createToken(typescript_1.default.SyntaxKind.EqualsGreaterThanToken), factory_1.factory.createParenthesizedExpression(factory_1.factory.createObjectLiteralExpression([
            factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('url'), generatePathExpression(path, pickParams('path'), rootObject, isFlatArg)),
            isQuery && verb.toUpperCase() === 'GET'
                ? undefined
                : factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('method'), factory_1.factory.createStringLiteral(verb.toUpperCase())),
            bodyParameter === undefined
                ? undefined
                : factory_1.factory.createPropertyAssignment(factory_1.factory.createIdentifier('body'), isFlatArg
                    ? rootObject
                    : factory_1.factory.createPropertyAccessExpression(rootObject, factory_1.factory.createIdentifier(bodyParameter.name))),
            createObjectLiteralProperty(pickParams('cookie'), 'cookies'),
            createObjectLiteralProperty(pickParams('header'), 'headers'),
            createObjectLiteralProperty(pickParams('query'), 'params'),
        ].filter(utils_1.removeUndefined), false)));
    }
    // eslint-disable-next-line no-empty-pattern
    function generateQueryEndpointProps({}) {
        return {}; /* TODO needs implementation - skip for now */
    }
    // eslint-disable-next-line no-empty-pattern
    function generateMutationEndpointProps({}) {
        return {}; /* TODO needs implementation - skip for now */
    }
}
exports.generateApi = generateApi;
function accessProperty(rootObject, propertyName) {
    return (0, tscodegen_1.isValidIdentifier)(propertyName)
        ? factory_1.factory.createPropertyAccessExpression(rootObject, factory_1.factory.createIdentifier(propertyName))
        : factory_1.factory.createElementAccessExpression(rootObject, factory_1.factory.createStringLiteral(propertyName));
}
function generatePathExpression(path, pathParameters, rootObject, isFlatArg) {
    const expressions = [];
    const head = path.replace(/\{(.*?)}(.*?)(?=\{|$)/g, (_, expression, literal) => {
        const param = pathParameters.find((p) => p.originalName === expression);
        if (!param) {
            throw new Error(`path parameter ${expression} does not seem to be defined in '${path}'!`);
        }
        expressions.push([param.name, literal]);
        return '';
    });
    return expressions.length
        ? factory_1.factory.createTemplateExpression(factory_1.factory.createTemplateHead(head), expressions.map(([prop, literal], index) => factory_1.factory.createTemplateSpan(isFlatArg ? rootObject : accessProperty(rootObject, prop), index === expressions.length - 1
            ? factory_1.factory.createTemplateTail(literal)
            : factory_1.factory.createTemplateMiddle(literal))))
        : factory_1.factory.createNoSubstitutionTemplateLiteral(head);
}
//# sourceMappingURL=generate.js.map