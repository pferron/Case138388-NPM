import ts from 'typescript';
declare function createImportSpecifier(propertyName: ts.Identifier | undefined, name: ts.Identifier): ts.ImportSpecifier;
declare function createExportSpecifier(propertyName: string | ts.Identifier | undefined, name: string | ts.Identifier): ts.ExportSpecifier;
export declare const factory: {
    createImportSpecifier: typeof createImportSpecifier;
    createExportSpecifier: typeof createExportSpecifier;
    createNodeArray<T extends ts.Node>(elements?: readonly T[] | undefined, hasTrailingComma?: boolean | undefined): ts.NodeArray<T>;
    createNumericLiteral(value: string | number, numericLiteralFlags?: ts.TokenFlags | undefined): ts.NumericLiteral;
    createBigIntLiteral(value: string | ts.PseudoBigInt): ts.BigIntLiteral;
    createStringLiteral(text: string, isSingleQuote?: boolean | undefined): ts.StringLiteral;
    createStringLiteralFromNode(sourceNode: ts.PrivateIdentifier | ts.PropertyNameLiteral, isSingleQuote?: boolean | undefined): ts.StringLiteral;
    createRegularExpressionLiteral(text: string): ts.RegularExpressionLiteral;
    createIdentifier(text: string): ts.Identifier;
    createTempVariable(recordTempVariable: ((node: ts.Identifier) => void) | undefined, reservedInNestedScopes?: boolean | undefined): ts.Identifier;
    createLoopVariable(reservedInNestedScopes?: boolean | undefined): ts.Identifier;
    createUniqueName(text: string, flags?: ts.GeneratedIdentifierFlags | undefined): ts.Identifier;
    getGeneratedNameForNode(node: ts.Node | undefined, flags?: ts.GeneratedIdentifierFlags | undefined): ts.Identifier;
    createPrivateIdentifier(text: string): ts.PrivateIdentifier;
    createUniquePrivateName(text?: string | undefined): ts.PrivateIdentifier;
    getGeneratedPrivateNameForNode(node: ts.Node): ts.PrivateIdentifier;
    createToken(token: ts.SyntaxKind.SuperKeyword): ts.SuperExpression;
    createToken(token: ts.SyntaxKind.ThisKeyword): ts.ThisExpression;
    createToken(token: ts.SyntaxKind.NullKeyword): ts.NullLiteral;
    createToken(token: ts.SyntaxKind.TrueKeyword): ts.TrueLiteral;
    createToken(token: ts.SyntaxKind.FalseKeyword): ts.FalseLiteral;
    createToken(token: ts.SyntaxKind.EndOfFileToken): ts.EndOfFileToken;
    createToken(token: ts.SyntaxKind.Unknown): ts.Token<ts.SyntaxKind.Unknown>;
    createToken<TKind extends ts.PunctuationSyntaxKind>(token: TKind): ts.PunctuationToken<TKind>;
    createToken<TKind_1 extends ts.KeywordTypeSyntaxKind>(token: TKind_1): ts.KeywordTypeNode<TKind_1>;
    createToken<TKind_2 extends ts.ModifierSyntaxKind>(token: TKind_2): ts.ModifierToken<TKind_2>;
    createToken<TKind_3 extends ts.KeywordSyntaxKind>(token: TKind_3): ts.KeywordToken<TKind_3>;
    createSuper(): ts.SuperExpression;
    createThis(): ts.ThisExpression;
    createNull(): ts.NullLiteral;
    createTrue(): ts.TrueLiteral;
    createFalse(): ts.FalseLiteral;
    createModifier<T_1 extends ts.ModifierSyntaxKind>(kind: T_1): ts.ModifierToken<T_1>;
    createModifiersFromModifierFlags(flags: ts.ModifierFlags): ts.Modifier[] | undefined;
    createQualifiedName(left: ts.EntityName, right: string | ts.Identifier): ts.QualifiedName;
    updateQualifiedName(node: ts.QualifiedName, left: ts.EntityName, right: ts.Identifier): ts.QualifiedName;
    createComputedPropertyName(expression: ts.Expression): ts.ComputedPropertyName;
    updateComputedPropertyName(node: ts.ComputedPropertyName, expression: ts.Expression): ts.ComputedPropertyName;
    createTypeParameterDeclaration(modifiers: readonly ts.Modifier[] | undefined, name: string | ts.Identifier, constraint?: ts.TypeNode | undefined, defaultType?: ts.TypeNode | undefined): ts.TypeParameterDeclaration;
    updateTypeParameterDeclaration(node: ts.TypeParameterDeclaration, modifiers: readonly ts.Modifier[] | undefined, name: ts.Identifier, constraint: ts.TypeNode | undefined, defaultType: ts.TypeNode | undefined): ts.TypeParameterDeclaration;
    createParameterDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, dotDotDotToken: ts.DotDotDotToken | undefined, name: string | ts.BindingName, questionToken?: ts.QuestionToken | undefined, type?: ts.TypeNode | undefined, initializer?: ts.Expression | undefined): ts.ParameterDeclaration;
    updateParameterDeclaration(node: ts.ParameterDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, dotDotDotToken: ts.DotDotDotToken | undefined, name: string | ts.BindingName, questionToken: ts.QuestionToken | undefined, type: ts.TypeNode | undefined, initializer: ts.Expression | undefined): ts.ParameterDeclaration;
    createDecorator(expression: ts.Expression): ts.Decorator;
    updateDecorator(node: ts.Decorator, expression: ts.Expression): ts.Decorator;
    createPropertySignature(modifiers: readonly ts.Modifier[] | undefined, name: string | ts.PropertyName, questionToken: ts.QuestionToken | undefined, type: ts.TypeNode | undefined): ts.PropertySignature;
    updatePropertySignature(node: ts.PropertySignature, modifiers: readonly ts.Modifier[] | undefined, name: ts.PropertyName, questionToken: ts.QuestionToken | undefined, type: ts.TypeNode | undefined): ts.PropertySignature;
    createPropertyDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.PropertyName, questionOrExclamationToken: ts.QuestionToken | ts.ExclamationToken | undefined, type: ts.TypeNode | undefined, initializer: ts.Expression | undefined): ts.PropertyDeclaration;
    updatePropertyDeclaration(node: ts.PropertyDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.PropertyName, questionOrExclamationToken: ts.QuestionToken | ts.ExclamationToken | undefined, type: ts.TypeNode | undefined, initializer: ts.Expression | undefined): ts.PropertyDeclaration;
    createMethodSignature(modifiers: readonly ts.Modifier[] | undefined, name: string | ts.PropertyName, questionToken: ts.QuestionToken | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined): ts.MethodSignature;
    updateMethodSignature(node: ts.MethodSignature, modifiers: readonly ts.Modifier[] | undefined, name: ts.PropertyName, questionToken: ts.QuestionToken | undefined, typeParameters: ts.NodeArray<ts.TypeParameterDeclaration> | undefined, parameters: ts.NodeArray<ts.ParameterDeclaration>, type: ts.TypeNode | undefined): ts.MethodSignature;
    createMethodDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, asteriskToken: ts.AsteriskToken | undefined, name: string | ts.PropertyName, questionToken: ts.QuestionToken | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, body: ts.Block | undefined): ts.MethodDeclaration;
    updateMethodDeclaration(node: ts.MethodDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, asteriskToken: ts.AsteriskToken | undefined, name: ts.PropertyName, questionToken: ts.QuestionToken | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, body: ts.Block | undefined): ts.MethodDeclaration;
    createConstructorDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, parameters: readonly ts.ParameterDeclaration[], body: ts.Block | undefined): ts.ConstructorDeclaration;
    updateConstructorDeclaration(node: ts.ConstructorDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, parameters: readonly ts.ParameterDeclaration[], body: ts.Block | undefined): ts.ConstructorDeclaration;
    createGetAccessorDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.PropertyName, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, body: ts.Block | undefined): ts.GetAccessorDeclaration;
    updateGetAccessorDeclaration(node: ts.GetAccessorDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, name: ts.PropertyName, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, body: ts.Block | undefined): ts.GetAccessorDeclaration;
    createSetAccessorDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.PropertyName, parameters: readonly ts.ParameterDeclaration[], body: ts.Block | undefined): ts.SetAccessorDeclaration;
    updateSetAccessorDeclaration(node: ts.SetAccessorDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, name: ts.PropertyName, parameters: readonly ts.ParameterDeclaration[], body: ts.Block | undefined): ts.SetAccessorDeclaration;
    createCallSignature(typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined): ts.CallSignatureDeclaration;
    updateCallSignature(node: ts.CallSignatureDeclaration, typeParameters: ts.NodeArray<ts.TypeParameterDeclaration> | undefined, parameters: ts.NodeArray<ts.ParameterDeclaration>, type: ts.TypeNode | undefined): ts.CallSignatureDeclaration;
    createConstructSignature(typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined): ts.ConstructSignatureDeclaration;
    updateConstructSignature(node: ts.ConstructSignatureDeclaration, typeParameters: ts.NodeArray<ts.TypeParameterDeclaration> | undefined, parameters: ts.NodeArray<ts.ParameterDeclaration>, type: ts.TypeNode | undefined): ts.ConstructSignatureDeclaration;
    createIndexSignature(modifiers: readonly ts.ModifierLike[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode): ts.IndexSignatureDeclaration;
    updateIndexSignature(node: ts.IndexSignatureDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode): ts.IndexSignatureDeclaration;
    createTemplateLiteralTypeSpan(type: ts.TypeNode, literal: ts.TemplateMiddle | ts.TemplateTail): ts.TemplateLiteralTypeSpan;
    updateTemplateLiteralTypeSpan(node: ts.TemplateLiteralTypeSpan, type: ts.TypeNode, literal: ts.TemplateMiddle | ts.TemplateTail): ts.TemplateLiteralTypeSpan;
    createClassStaticBlockDeclaration(body: ts.Block): ts.ClassStaticBlockDeclaration;
    updateClassStaticBlockDeclaration(node: ts.ClassStaticBlockDeclaration, body: ts.Block): ts.ClassStaticBlockDeclaration;
    createKeywordTypeNode<TKind_4 extends ts.KeywordTypeSyntaxKind>(kind: TKind_4): ts.KeywordTypeNode<TKind_4>;
    createTypePredicateNode(assertsModifier: ts.AssertsKeyword | undefined, parameterName: string | ts.Identifier | ts.ThisTypeNode, type: ts.TypeNode | undefined): ts.TypePredicateNode;
    updateTypePredicateNode(node: ts.TypePredicateNode, assertsModifier: ts.AssertsKeyword | undefined, parameterName: ts.Identifier | ts.ThisTypeNode, type: ts.TypeNode | undefined): ts.TypePredicateNode;
    createTypeReferenceNode(typeName: string | ts.EntityName, typeArguments?: readonly ts.TypeNode[] | undefined): ts.TypeReferenceNode;
    updateTypeReferenceNode(node: ts.TypeReferenceNode, typeName: ts.EntityName, typeArguments: ts.NodeArray<ts.TypeNode> | undefined): ts.TypeReferenceNode;
    createFunctionTypeNode(typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode): ts.FunctionTypeNode;
    updateFunctionTypeNode(node: ts.FunctionTypeNode, typeParameters: ts.NodeArray<ts.TypeParameterDeclaration> | undefined, parameters: ts.NodeArray<ts.ParameterDeclaration>, type: ts.TypeNode): ts.FunctionTypeNode;
    createConstructorTypeNode(modifiers: readonly ts.Modifier[] | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode): ts.ConstructorTypeNode;
    updateConstructorTypeNode(node: ts.ConstructorTypeNode, modifiers: readonly ts.Modifier[] | undefined, typeParameters: ts.NodeArray<ts.TypeParameterDeclaration> | undefined, parameters: ts.NodeArray<ts.ParameterDeclaration>, type: ts.TypeNode): ts.ConstructorTypeNode;
    createTypeQueryNode(exprName: ts.EntityName, typeArguments?: readonly ts.TypeNode[] | undefined): ts.TypeQueryNode;
    updateTypeQueryNode(node: ts.TypeQueryNode, exprName: ts.EntityName, typeArguments?: readonly ts.TypeNode[] | undefined): ts.TypeQueryNode;
    createTypeLiteralNode(members: readonly ts.TypeElement[] | undefined): ts.TypeLiteralNode;
    updateTypeLiteralNode(node: ts.TypeLiteralNode, members: ts.NodeArray<ts.TypeElement>): ts.TypeLiteralNode;
    createArrayTypeNode(elementType: ts.TypeNode): ts.ArrayTypeNode;
    updateArrayTypeNode(node: ts.ArrayTypeNode, elementType: ts.TypeNode): ts.ArrayTypeNode;
    createTupleTypeNode(elements: readonly (ts.TypeNode | ts.NamedTupleMember)[]): ts.TupleTypeNode;
    updateTupleTypeNode(node: ts.TupleTypeNode, elements: readonly (ts.TypeNode | ts.NamedTupleMember)[]): ts.TupleTypeNode;
    createNamedTupleMember(dotDotDotToken: ts.DotDotDotToken | undefined, name: ts.Identifier, questionToken: ts.QuestionToken | undefined, type: ts.TypeNode): ts.NamedTupleMember;
    updateNamedTupleMember(node: ts.NamedTupleMember, dotDotDotToken: ts.DotDotDotToken | undefined, name: ts.Identifier, questionToken: ts.QuestionToken | undefined, type: ts.TypeNode): ts.NamedTupleMember;
    createOptionalTypeNode(type: ts.TypeNode): ts.OptionalTypeNode;
    updateOptionalTypeNode(node: ts.OptionalTypeNode, type: ts.TypeNode): ts.OptionalTypeNode;
    createRestTypeNode(type: ts.TypeNode): ts.RestTypeNode;
    updateRestTypeNode(node: ts.RestTypeNode, type: ts.TypeNode): ts.RestTypeNode;
    createUnionTypeNode(types: readonly ts.TypeNode[]): ts.UnionTypeNode;
    updateUnionTypeNode(node: ts.UnionTypeNode, types: ts.NodeArray<ts.TypeNode>): ts.UnionTypeNode;
    createIntersectionTypeNode(types: readonly ts.TypeNode[]): ts.IntersectionTypeNode;
    updateIntersectionTypeNode(node: ts.IntersectionTypeNode, types: ts.NodeArray<ts.TypeNode>): ts.IntersectionTypeNode;
    createConditionalTypeNode(checkType: ts.TypeNode, extendsType: ts.TypeNode, trueType: ts.TypeNode, falseType: ts.TypeNode): ts.ConditionalTypeNode;
    updateConditionalTypeNode(node: ts.ConditionalTypeNode, checkType: ts.TypeNode, extendsType: ts.TypeNode, trueType: ts.TypeNode, falseType: ts.TypeNode): ts.ConditionalTypeNode;
    createInferTypeNode(typeParameter: ts.TypeParameterDeclaration): ts.InferTypeNode;
    updateInferTypeNode(node: ts.InferTypeNode, typeParameter: ts.TypeParameterDeclaration): ts.InferTypeNode;
    createImportTypeNode(argument: ts.TypeNode, assertions?: ts.ImportTypeAssertionContainer | undefined, qualifier?: ts.EntityName | undefined, typeArguments?: readonly ts.TypeNode[] | undefined, isTypeOf?: boolean | undefined): ts.ImportTypeNode;
    updateImportTypeNode(node: ts.ImportTypeNode, argument: ts.TypeNode, assertions: ts.ImportTypeAssertionContainer | undefined, qualifier: ts.EntityName | undefined, typeArguments: readonly ts.TypeNode[] | undefined, isTypeOf?: boolean | undefined): ts.ImportTypeNode;
    createParenthesizedType(type: ts.TypeNode): ts.ParenthesizedTypeNode;
    updateParenthesizedType(node: ts.ParenthesizedTypeNode, type: ts.TypeNode): ts.ParenthesizedTypeNode;
    createThisTypeNode(): ts.ThisTypeNode;
    createTypeOperatorNode(operator: ts.SyntaxKind.KeyOfKeyword | ts.SyntaxKind.ReadonlyKeyword | ts.SyntaxKind.UniqueKeyword, type: ts.TypeNode): ts.TypeOperatorNode;
    updateTypeOperatorNode(node: ts.TypeOperatorNode, type: ts.TypeNode): ts.TypeOperatorNode;
    createIndexedAccessTypeNode(objectType: ts.TypeNode, indexType: ts.TypeNode): ts.IndexedAccessTypeNode;
    updateIndexedAccessTypeNode(node: ts.IndexedAccessTypeNode, objectType: ts.TypeNode, indexType: ts.TypeNode): ts.IndexedAccessTypeNode;
    createMappedTypeNode(readonlyToken: ts.ReadonlyKeyword | ts.PlusToken | ts.MinusToken | undefined, typeParameter: ts.TypeParameterDeclaration, nameType: ts.TypeNode | undefined, questionToken: ts.QuestionToken | ts.PlusToken | ts.MinusToken | undefined, type: ts.TypeNode | undefined, members: ts.NodeArray<ts.TypeElement> | undefined): ts.MappedTypeNode;
    updateMappedTypeNode(node: ts.MappedTypeNode, readonlyToken: ts.ReadonlyKeyword | ts.PlusToken | ts.MinusToken | undefined, typeParameter: ts.TypeParameterDeclaration, nameType: ts.TypeNode | undefined, questionToken: ts.QuestionToken | ts.PlusToken | ts.MinusToken | undefined, type: ts.TypeNode | undefined, members: ts.NodeArray<ts.TypeElement> | undefined): ts.MappedTypeNode;
    createLiteralTypeNode(literal: ts.LiteralExpression | ts.NullLiteral | ts.BooleanLiteral | ts.PrefixUnaryExpression): ts.LiteralTypeNode;
    updateLiteralTypeNode(node: ts.LiteralTypeNode, literal: ts.LiteralExpression | ts.NullLiteral | ts.BooleanLiteral | ts.PrefixUnaryExpression): ts.LiteralTypeNode;
    createTemplateLiteralType(head: ts.TemplateHead, templateSpans: readonly ts.TemplateLiteralTypeSpan[]): ts.TemplateLiteralTypeNode;
    updateTemplateLiteralType(node: ts.TemplateLiteralTypeNode, head: ts.TemplateHead, templateSpans: readonly ts.TemplateLiteralTypeSpan[]): ts.TemplateLiteralTypeNode;
    createObjectBindingPattern(elements: readonly ts.BindingElement[]): ts.ObjectBindingPattern;
    updateObjectBindingPattern(node: ts.ObjectBindingPattern, elements: readonly ts.BindingElement[]): ts.ObjectBindingPattern;
    createArrayBindingPattern(elements: readonly ts.ArrayBindingElement[]): ts.ArrayBindingPattern;
    updateArrayBindingPattern(node: ts.ArrayBindingPattern, elements: readonly ts.ArrayBindingElement[]): ts.ArrayBindingPattern;
    createBindingElement(dotDotDotToken: ts.DotDotDotToken | undefined, propertyName: string | ts.PropertyName | undefined, name: string | ts.BindingName, initializer?: ts.Expression | undefined): ts.BindingElement;
    updateBindingElement(node: ts.BindingElement, dotDotDotToken: ts.DotDotDotToken | undefined, propertyName: ts.PropertyName | undefined, name: ts.BindingName, initializer: ts.Expression | undefined): ts.BindingElement;
    createArrayLiteralExpression(elements?: readonly ts.Expression[] | undefined, multiLine?: boolean | undefined): ts.ArrayLiteralExpression;
    updateArrayLiteralExpression(node: ts.ArrayLiteralExpression, elements: readonly ts.Expression[]): ts.ArrayLiteralExpression;
    createObjectLiteralExpression(properties?: readonly ts.ObjectLiteralElementLike[] | undefined, multiLine?: boolean | undefined): ts.ObjectLiteralExpression;
    updateObjectLiteralExpression(node: ts.ObjectLiteralExpression, properties: readonly ts.ObjectLiteralElementLike[]): ts.ObjectLiteralExpression;
    createPropertyAccessExpression(expression: ts.Expression, name: string | ts.MemberName): ts.PropertyAccessExpression;
    updatePropertyAccessExpression(node: ts.PropertyAccessExpression, expression: ts.Expression, name: ts.MemberName): ts.PropertyAccessExpression;
    createPropertyAccessChain(expression: ts.Expression, questionDotToken: ts.QuestionDotToken | undefined, name: string | ts.MemberName): ts.PropertyAccessChain;
    updatePropertyAccessChain(node: ts.PropertyAccessChain, expression: ts.Expression, questionDotToken: ts.QuestionDotToken | undefined, name: ts.MemberName): ts.PropertyAccessChain;
    createElementAccessExpression(expression: ts.Expression, index: number | ts.Expression): ts.ElementAccessExpression;
    updateElementAccessExpression(node: ts.ElementAccessExpression, expression: ts.Expression, argumentExpression: ts.Expression): ts.ElementAccessExpression;
    createElementAccessChain(expression: ts.Expression, questionDotToken: ts.QuestionDotToken | undefined, index: number | ts.Expression): ts.ElementAccessChain;
    updateElementAccessChain(node: ts.ElementAccessChain, expression: ts.Expression, questionDotToken: ts.QuestionDotToken | undefined, argumentExpression: ts.Expression): ts.ElementAccessChain;
    createCallExpression(expression: ts.Expression, typeArguments: readonly ts.TypeNode[] | undefined, argumentsArray: readonly ts.Expression[] | undefined): ts.CallExpression;
    updateCallExpression(node: ts.CallExpression, expression: ts.Expression, typeArguments: readonly ts.TypeNode[] | undefined, argumentsArray: readonly ts.Expression[]): ts.CallExpression;
    createCallChain(expression: ts.Expression, questionDotToken: ts.QuestionDotToken | undefined, typeArguments: readonly ts.TypeNode[] | undefined, argumentsArray: readonly ts.Expression[] | undefined): ts.CallChain;
    updateCallChain(node: ts.CallChain, expression: ts.Expression, questionDotToken: ts.QuestionDotToken | undefined, typeArguments: readonly ts.TypeNode[] | undefined, argumentsArray: readonly ts.Expression[]): ts.CallChain;
    createNewExpression(expression: ts.Expression, typeArguments: readonly ts.TypeNode[] | undefined, argumentsArray: readonly ts.Expression[] | undefined): ts.NewExpression;
    updateNewExpression(node: ts.NewExpression, expression: ts.Expression, typeArguments: readonly ts.TypeNode[] | undefined, argumentsArray: readonly ts.Expression[] | undefined): ts.NewExpression;
    createTaggedTemplateExpression(tag: ts.Expression, typeArguments: readonly ts.TypeNode[] | undefined, template: ts.TemplateLiteral): ts.TaggedTemplateExpression;
    updateTaggedTemplateExpression(node: ts.TaggedTemplateExpression, tag: ts.Expression, typeArguments: readonly ts.TypeNode[] | undefined, template: ts.TemplateLiteral): ts.TaggedTemplateExpression;
    createTypeAssertion(type: ts.TypeNode, expression: ts.Expression): ts.TypeAssertion;
    updateTypeAssertion(node: ts.TypeAssertion, type: ts.TypeNode, expression: ts.Expression): ts.TypeAssertion;
    createParenthesizedExpression(expression: ts.Expression): ts.ParenthesizedExpression;
    updateParenthesizedExpression(node: ts.ParenthesizedExpression, expression: ts.Expression): ts.ParenthesizedExpression;
    createFunctionExpression(modifiers: readonly ts.Modifier[] | undefined, asteriskToken: ts.AsteriskToken | undefined, name: string | ts.Identifier | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[] | undefined, type: ts.TypeNode | undefined, body: ts.Block): ts.FunctionExpression;
    updateFunctionExpression(node: ts.FunctionExpression, modifiers: readonly ts.Modifier[] | undefined, asteriskToken: ts.AsteriskToken | undefined, name: ts.Identifier | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, body: ts.Block): ts.FunctionExpression;
    createArrowFunction(modifiers: readonly ts.Modifier[] | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, equalsGreaterThanToken: ts.EqualsGreaterThanToken | undefined, body: ts.ConciseBody): ts.ArrowFunction;
    updateArrowFunction(node: ts.ArrowFunction, modifiers: readonly ts.Modifier[] | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, equalsGreaterThanToken: ts.EqualsGreaterThanToken, body: ts.ConciseBody): ts.ArrowFunction;
    createDeleteExpression(expression: ts.Expression): ts.DeleteExpression;
    updateDeleteExpression(node: ts.DeleteExpression, expression: ts.Expression): ts.DeleteExpression;
    createTypeOfExpression(expression: ts.Expression): ts.TypeOfExpression;
    updateTypeOfExpression(node: ts.TypeOfExpression, expression: ts.Expression): ts.TypeOfExpression;
    createVoidExpression(expression: ts.Expression): ts.VoidExpression;
    updateVoidExpression(node: ts.VoidExpression, expression: ts.Expression): ts.VoidExpression;
    createAwaitExpression(expression: ts.Expression): ts.AwaitExpression;
    updateAwaitExpression(node: ts.AwaitExpression, expression: ts.Expression): ts.AwaitExpression;
    createPrefixUnaryExpression(operator: ts.PrefixUnaryOperator, operand: ts.Expression): ts.PrefixUnaryExpression;
    updatePrefixUnaryExpression(node: ts.PrefixUnaryExpression, operand: ts.Expression): ts.PrefixUnaryExpression;
    createPostfixUnaryExpression(operand: ts.Expression, operator: ts.PostfixUnaryOperator): ts.PostfixUnaryExpression;
    updatePostfixUnaryExpression(node: ts.PostfixUnaryExpression, operand: ts.Expression): ts.PostfixUnaryExpression;
    createBinaryExpression(left: ts.Expression, operator: ts.BinaryOperator | ts.BinaryOperatorToken, right: ts.Expression): ts.BinaryExpression;
    updateBinaryExpression(node: ts.BinaryExpression, left: ts.Expression, operator: ts.BinaryOperator | ts.BinaryOperatorToken, right: ts.Expression): ts.BinaryExpression;
    createConditionalExpression(condition: ts.Expression, questionToken: ts.QuestionToken | undefined, whenTrue: ts.Expression, colonToken: ts.ColonToken | undefined, whenFalse: ts.Expression): ts.ConditionalExpression;
    updateConditionalExpression(node: ts.ConditionalExpression, condition: ts.Expression, questionToken: ts.QuestionToken, whenTrue: ts.Expression, colonToken: ts.ColonToken, whenFalse: ts.Expression): ts.ConditionalExpression;
    createTemplateExpression(head: ts.TemplateHead, templateSpans: readonly ts.TemplateSpan[]): ts.TemplateExpression;
    updateTemplateExpression(node: ts.TemplateExpression, head: ts.TemplateHead, templateSpans: readonly ts.TemplateSpan[]): ts.TemplateExpression;
    createTemplateHead(text: string, rawText?: string | undefined, templateFlags?: ts.TokenFlags | undefined): ts.TemplateHead;
    createTemplateHead(text: string | undefined, rawText: string, templateFlags?: ts.TokenFlags | undefined): ts.TemplateHead;
    createTemplateMiddle(text: string, rawText?: string | undefined, templateFlags?: ts.TokenFlags | undefined): ts.TemplateMiddle;
    createTemplateMiddle(text: string | undefined, rawText: string, templateFlags?: ts.TokenFlags | undefined): ts.TemplateMiddle;
    createTemplateTail(text: string, rawText?: string | undefined, templateFlags?: ts.TokenFlags | undefined): ts.TemplateTail;
    createTemplateTail(text: string | undefined, rawText: string, templateFlags?: ts.TokenFlags | undefined): ts.TemplateTail;
    createNoSubstitutionTemplateLiteral(text: string, rawText?: string | undefined): ts.NoSubstitutionTemplateLiteral;
    createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): ts.NoSubstitutionTemplateLiteral;
    createYieldExpression(asteriskToken: ts.AsteriskToken, expression: ts.Expression): ts.YieldExpression;
    createYieldExpression(asteriskToken: undefined, expression: ts.Expression | undefined): ts.YieldExpression;
    updateYieldExpression(node: ts.YieldExpression, asteriskToken: ts.AsteriskToken | undefined, expression: ts.Expression | undefined): ts.YieldExpression;
    createSpreadElement(expression: ts.Expression): ts.SpreadElement;
    updateSpreadElement(node: ts.SpreadElement, expression: ts.Expression): ts.SpreadElement;
    createClassExpression(modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.Identifier | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, heritageClauses: readonly ts.HeritageClause[] | undefined, members: readonly ts.ClassElement[]): ts.ClassExpression;
    updateClassExpression(node: ts.ClassExpression, modifiers: readonly ts.ModifierLike[] | undefined, name: ts.Identifier | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, heritageClauses: readonly ts.HeritageClause[] | undefined, members: readonly ts.ClassElement[]): ts.ClassExpression;
    createOmittedExpression(): ts.OmittedExpression;
    createExpressionWithTypeArguments(expression: ts.Expression, typeArguments: readonly ts.TypeNode[] | undefined): ts.ExpressionWithTypeArguments;
    updateExpressionWithTypeArguments(node: ts.ExpressionWithTypeArguments, expression: ts.Expression, typeArguments: readonly ts.TypeNode[] | undefined): ts.ExpressionWithTypeArguments;
    createAsExpression(expression: ts.Expression, type: ts.TypeNode): ts.AsExpression;
    updateAsExpression(node: ts.AsExpression, expression: ts.Expression, type: ts.TypeNode): ts.AsExpression;
    createNonNullExpression(expression: ts.Expression): ts.NonNullExpression;
    updateNonNullExpression(node: ts.NonNullExpression, expression: ts.Expression): ts.NonNullExpression;
    createNonNullChain(expression: ts.Expression): ts.NonNullChain;
    updateNonNullChain(node: ts.NonNullChain, expression: ts.Expression): ts.NonNullChain;
    createMetaProperty(keywordToken: ts.SyntaxKind.ImportKeyword | ts.SyntaxKind.NewKeyword, name: ts.Identifier): ts.MetaProperty;
    updateMetaProperty(node: ts.MetaProperty, name: ts.Identifier): ts.MetaProperty;
    createSatisfiesExpression(expression: ts.Expression, type: ts.TypeNode): ts.SatisfiesExpression;
    updateSatisfiesExpression(node: ts.SatisfiesExpression, expression: ts.Expression, type: ts.TypeNode): ts.SatisfiesExpression;
    createTemplateSpan(expression: ts.Expression, literal: ts.TemplateMiddle | ts.TemplateTail): ts.TemplateSpan;
    updateTemplateSpan(node: ts.TemplateSpan, expression: ts.Expression, literal: ts.TemplateMiddle | ts.TemplateTail): ts.TemplateSpan;
    createSemicolonClassElement(): ts.SemicolonClassElement;
    createBlock(statements: readonly ts.Statement[], multiLine?: boolean | undefined): ts.Block;
    updateBlock(node: ts.Block, statements: readonly ts.Statement[]): ts.Block;
    createVariableStatement(modifiers: readonly ts.ModifierLike[] | undefined, declarationList: ts.VariableDeclarationList | readonly ts.VariableDeclaration[]): ts.VariableStatement;
    updateVariableStatement(node: ts.VariableStatement, modifiers: readonly ts.ModifierLike[] | undefined, declarationList: ts.VariableDeclarationList): ts.VariableStatement;
    createEmptyStatement(): ts.EmptyStatement;
    createExpressionStatement(expression: ts.Expression): ts.ExpressionStatement;
    updateExpressionStatement(node: ts.ExpressionStatement, expression: ts.Expression): ts.ExpressionStatement;
    createIfStatement(expression: ts.Expression, thenStatement: ts.Statement, elseStatement?: ts.Statement | undefined): ts.IfStatement;
    updateIfStatement(node: ts.IfStatement, expression: ts.Expression, thenStatement: ts.Statement, elseStatement: ts.Statement | undefined): ts.IfStatement;
    createDoStatement(statement: ts.Statement, expression: ts.Expression): ts.DoStatement;
    updateDoStatement(node: ts.DoStatement, statement: ts.Statement, expression: ts.Expression): ts.DoStatement;
    createWhileStatement(expression: ts.Expression, statement: ts.Statement): ts.WhileStatement;
    updateWhileStatement(node: ts.WhileStatement, expression: ts.Expression, statement: ts.Statement): ts.WhileStatement;
    createForStatement(initializer: ts.ForInitializer | undefined, condition: ts.Expression | undefined, incrementor: ts.Expression | undefined, statement: ts.Statement): ts.ForStatement;
    updateForStatement(node: ts.ForStatement, initializer: ts.ForInitializer | undefined, condition: ts.Expression | undefined, incrementor: ts.Expression | undefined, statement: ts.Statement): ts.ForStatement;
    createForInStatement(initializer: ts.ForInitializer, expression: ts.Expression, statement: ts.Statement): ts.ForInStatement;
    updateForInStatement(node: ts.ForInStatement, initializer: ts.ForInitializer, expression: ts.Expression, statement: ts.Statement): ts.ForInStatement;
    createForOfStatement(awaitModifier: ts.AwaitKeyword | undefined, initializer: ts.ForInitializer, expression: ts.Expression, statement: ts.Statement): ts.ForOfStatement;
    updateForOfStatement(node: ts.ForOfStatement, awaitModifier: ts.AwaitKeyword | undefined, initializer: ts.ForInitializer, expression: ts.Expression, statement: ts.Statement): ts.ForOfStatement;
    createContinueStatement(label?: string | ts.Identifier | undefined): ts.ContinueStatement;
    updateContinueStatement(node: ts.ContinueStatement, label: ts.Identifier | undefined): ts.ContinueStatement;
    createBreakStatement(label?: string | ts.Identifier | undefined): ts.BreakStatement;
    updateBreakStatement(node: ts.BreakStatement, label: ts.Identifier | undefined): ts.BreakStatement;
    createReturnStatement(expression?: ts.Expression | undefined): ts.ReturnStatement;
    updateReturnStatement(node: ts.ReturnStatement, expression: ts.Expression | undefined): ts.ReturnStatement;
    createWithStatement(expression: ts.Expression, statement: ts.Statement): ts.WithStatement;
    updateWithStatement(node: ts.WithStatement, expression: ts.Expression, statement: ts.Statement): ts.WithStatement;
    createSwitchStatement(expression: ts.Expression, caseBlock: ts.CaseBlock): ts.SwitchStatement;
    updateSwitchStatement(node: ts.SwitchStatement, expression: ts.Expression, caseBlock: ts.CaseBlock): ts.SwitchStatement;
    createLabeledStatement(label: string | ts.Identifier, statement: ts.Statement): ts.LabeledStatement;
    updateLabeledStatement(node: ts.LabeledStatement, label: ts.Identifier, statement: ts.Statement): ts.LabeledStatement;
    createThrowStatement(expression: ts.Expression): ts.ThrowStatement;
    updateThrowStatement(node: ts.ThrowStatement, expression: ts.Expression): ts.ThrowStatement;
    createTryStatement(tryBlock: ts.Block, catchClause: ts.CatchClause | undefined, finallyBlock: ts.Block | undefined): ts.TryStatement;
    updateTryStatement(node: ts.TryStatement, tryBlock: ts.Block, catchClause: ts.CatchClause | undefined, finallyBlock: ts.Block | undefined): ts.TryStatement;
    createDebuggerStatement(): ts.DebuggerStatement;
    createVariableDeclaration(name: string | ts.BindingName, exclamationToken?: ts.ExclamationToken | undefined, type?: ts.TypeNode | undefined, initializer?: ts.Expression | undefined): ts.VariableDeclaration;
    updateVariableDeclaration(node: ts.VariableDeclaration, name: ts.BindingName, exclamationToken: ts.ExclamationToken | undefined, type: ts.TypeNode | undefined, initializer: ts.Expression | undefined): ts.VariableDeclaration;
    createVariableDeclarationList(declarations: readonly ts.VariableDeclaration[], flags?: ts.NodeFlags | undefined): ts.VariableDeclarationList;
    updateVariableDeclarationList(node: ts.VariableDeclarationList, declarations: readonly ts.VariableDeclaration[]): ts.VariableDeclarationList;
    createFunctionDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, asteriskToken: ts.AsteriskToken | undefined, name: string | ts.Identifier | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, body: ts.Block | undefined): ts.FunctionDeclaration;
    updateFunctionDeclaration(node: ts.FunctionDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, asteriskToken: ts.AsteriskToken | undefined, name: ts.Identifier | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined, body: ts.Block | undefined): ts.FunctionDeclaration;
    createClassDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.Identifier | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, heritageClauses: readonly ts.HeritageClause[] | undefined, members: readonly ts.ClassElement[]): ts.ClassDeclaration;
    updateClassDeclaration(node: ts.ClassDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, name: ts.Identifier | undefined, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, heritageClauses: readonly ts.HeritageClause[] | undefined, members: readonly ts.ClassElement[]): ts.ClassDeclaration;
    createInterfaceDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.Identifier, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, heritageClauses: readonly ts.HeritageClause[] | undefined, members: readonly ts.TypeElement[]): ts.InterfaceDeclaration;
    updateInterfaceDeclaration(node: ts.InterfaceDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, name: ts.Identifier, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, heritageClauses: readonly ts.HeritageClause[] | undefined, members: readonly ts.TypeElement[]): ts.InterfaceDeclaration;
    createTypeAliasDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.Identifier, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, type: ts.TypeNode): ts.TypeAliasDeclaration;
    updateTypeAliasDeclaration(node: ts.TypeAliasDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, name: ts.Identifier, typeParameters: readonly ts.TypeParameterDeclaration[] | undefined, type: ts.TypeNode): ts.TypeAliasDeclaration;
    createEnumDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, name: string | ts.Identifier, members: readonly ts.EnumMember[]): ts.EnumDeclaration;
    updateEnumDeclaration(node: ts.EnumDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, name: ts.Identifier, members: readonly ts.EnumMember[]): ts.EnumDeclaration;
    createModuleDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, name: ts.ModuleName, body: ts.ModuleBody | undefined, flags?: ts.NodeFlags | undefined): ts.ModuleDeclaration;
    updateModuleDeclaration(node: ts.ModuleDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, name: ts.ModuleName, body: ts.ModuleBody | undefined): ts.ModuleDeclaration;
    createModuleBlock(statements: readonly ts.Statement[]): ts.ModuleBlock;
    updateModuleBlock(node: ts.ModuleBlock, statements: readonly ts.Statement[]): ts.ModuleBlock;
    createCaseBlock(clauses: readonly ts.CaseOrDefaultClause[]): ts.CaseBlock;
    updateCaseBlock(node: ts.CaseBlock, clauses: readonly ts.CaseOrDefaultClause[]): ts.CaseBlock;
    createNamespaceExportDeclaration(name: string | ts.Identifier): ts.NamespaceExportDeclaration;
    updateNamespaceExportDeclaration(node: ts.NamespaceExportDeclaration, name: ts.Identifier): ts.NamespaceExportDeclaration;
    createImportEqualsDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, isTypeOnly: boolean, name: string | ts.Identifier, moduleReference: ts.ModuleReference): ts.ImportEqualsDeclaration;
    updateImportEqualsDeclaration(node: ts.ImportEqualsDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, isTypeOnly: boolean, name: ts.Identifier, moduleReference: ts.ModuleReference): ts.ImportEqualsDeclaration;
    createImportDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, importClause: ts.ImportClause | undefined, moduleSpecifier: ts.Expression, assertClause?: ts.AssertClause | undefined): ts.ImportDeclaration;
    updateImportDeclaration(node: ts.ImportDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, importClause: ts.ImportClause | undefined, moduleSpecifier: ts.Expression, assertClause: ts.AssertClause | undefined): ts.ImportDeclaration;
    createImportClause(isTypeOnly: boolean, name: ts.Identifier | undefined, namedBindings: ts.NamedImportBindings | undefined): ts.ImportClause;
    updateImportClause(node: ts.ImportClause, isTypeOnly: boolean, name: ts.Identifier | undefined, namedBindings: ts.NamedImportBindings | undefined): ts.ImportClause;
    createAssertClause(elements: ts.NodeArray<ts.AssertEntry>, multiLine?: boolean | undefined): ts.AssertClause;
    updateAssertClause(node: ts.AssertClause, elements: ts.NodeArray<ts.AssertEntry>, multiLine?: boolean | undefined): ts.AssertClause;
    createAssertEntry(name: ts.AssertionKey, value: ts.Expression): ts.AssertEntry;
    updateAssertEntry(node: ts.AssertEntry, name: ts.AssertionKey, value: ts.Expression): ts.AssertEntry;
    createImportTypeAssertionContainer(clause: ts.AssertClause, multiLine?: boolean | undefined): ts.ImportTypeAssertionContainer;
    updateImportTypeAssertionContainer(node: ts.ImportTypeAssertionContainer, clause: ts.AssertClause, multiLine?: boolean | undefined): ts.ImportTypeAssertionContainer;
    createNamespaceImport(name: ts.Identifier): ts.NamespaceImport;
    updateNamespaceImport(node: ts.NamespaceImport, name: ts.Identifier): ts.NamespaceImport;
    createNamespaceExport(name: ts.Identifier): ts.NamespaceExport;
    updateNamespaceExport(node: ts.NamespaceExport, name: ts.Identifier): ts.NamespaceExport;
    createNamedImports(elements: readonly ts.ImportSpecifier[]): ts.NamedImports;
    updateNamedImports(node: ts.NamedImports, elements: readonly ts.ImportSpecifier[]): ts.NamedImports;
    updateImportSpecifier(node: ts.ImportSpecifier, isTypeOnly: boolean, propertyName: ts.Identifier | undefined, name: ts.Identifier): ts.ImportSpecifier;
    createExportAssignment(modifiers: readonly ts.ModifierLike[] | undefined, isExportEquals: boolean | undefined, expression: ts.Expression): ts.ExportAssignment;
    updateExportAssignment(node: ts.ExportAssignment, modifiers: readonly ts.ModifierLike[] | undefined, expression: ts.Expression): ts.ExportAssignment;
    createExportDeclaration(modifiers: readonly ts.ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: ts.NamedExportBindings | undefined, moduleSpecifier?: ts.Expression | undefined, assertClause?: ts.AssertClause | undefined): ts.ExportDeclaration;
    updateExportDeclaration(node: ts.ExportDeclaration, modifiers: readonly ts.ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: ts.NamedExportBindings | undefined, moduleSpecifier: ts.Expression | undefined, assertClause: ts.AssertClause | undefined): ts.ExportDeclaration;
    createNamedExports(elements: readonly ts.ExportSpecifier[]): ts.NamedExports;
    updateNamedExports(node: ts.NamedExports, elements: readonly ts.ExportSpecifier[]): ts.NamedExports;
    updateExportSpecifier(node: ts.ExportSpecifier, isTypeOnly: boolean, propertyName: ts.Identifier | undefined, name: ts.Identifier): ts.ExportSpecifier;
    createExternalModuleReference(expression: ts.Expression): ts.ExternalModuleReference;
    updateExternalModuleReference(node: ts.ExternalModuleReference, expression: ts.Expression): ts.ExternalModuleReference;
    createJSDocAllType(): ts.JSDocAllType;
    createJSDocUnknownType(): ts.JSDocUnknownType;
    createJSDocNonNullableType(type: ts.TypeNode, postfix?: boolean | undefined): ts.JSDocNonNullableType;
    updateJSDocNonNullableType(node: ts.JSDocNonNullableType, type: ts.TypeNode): ts.JSDocNonNullableType;
    createJSDocNullableType(type: ts.TypeNode, postfix?: boolean | undefined): ts.JSDocNullableType;
    updateJSDocNullableType(node: ts.JSDocNullableType, type: ts.TypeNode): ts.JSDocNullableType;
    createJSDocOptionalType(type: ts.TypeNode): ts.JSDocOptionalType;
    updateJSDocOptionalType(node: ts.JSDocOptionalType, type: ts.TypeNode): ts.JSDocOptionalType;
    createJSDocFunctionType(parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined): ts.JSDocFunctionType;
    updateJSDocFunctionType(node: ts.JSDocFunctionType, parameters: readonly ts.ParameterDeclaration[], type: ts.TypeNode | undefined): ts.JSDocFunctionType;
    createJSDocVariadicType(type: ts.TypeNode): ts.JSDocVariadicType;
    updateJSDocVariadicType(node: ts.JSDocVariadicType, type: ts.TypeNode): ts.JSDocVariadicType;
    createJSDocNamepathType(type: ts.TypeNode): ts.JSDocNamepathType;
    updateJSDocNamepathType(node: ts.JSDocNamepathType, type: ts.TypeNode): ts.JSDocNamepathType;
    createJSDocTypeExpression(type: ts.TypeNode): ts.JSDocTypeExpression;
    updateJSDocTypeExpression(node: ts.JSDocTypeExpression, type: ts.TypeNode): ts.JSDocTypeExpression;
    createJSDocNameReference(name: ts.EntityName | ts.JSDocMemberName): ts.JSDocNameReference;
    updateJSDocNameReference(node: ts.JSDocNameReference, name: ts.EntityName | ts.JSDocMemberName): ts.JSDocNameReference;
    createJSDocMemberName(left: ts.EntityName | ts.JSDocMemberName, right: ts.Identifier): ts.JSDocMemberName;
    updateJSDocMemberName(node: ts.JSDocMemberName, left: ts.EntityName | ts.JSDocMemberName, right: ts.Identifier): ts.JSDocMemberName;
    createJSDocLink(name: ts.EntityName | ts.JSDocMemberName | undefined, text: string): ts.JSDocLink;
    updateJSDocLink(node: ts.JSDocLink, name: ts.EntityName | ts.JSDocMemberName | undefined, text: string): ts.JSDocLink;
    createJSDocLinkCode(name: ts.EntityName | ts.JSDocMemberName | undefined, text: string): ts.JSDocLinkCode;
    updateJSDocLinkCode(node: ts.JSDocLinkCode, name: ts.EntityName | ts.JSDocMemberName | undefined, text: string): ts.JSDocLinkCode;
    createJSDocLinkPlain(name: ts.EntityName | ts.JSDocMemberName | undefined, text: string): ts.JSDocLinkPlain;
    updateJSDocLinkPlain(node: ts.JSDocLinkPlain, name: ts.EntityName | ts.JSDocMemberName | undefined, text: string): ts.JSDocLinkPlain;
    createJSDocTypeLiteral(jsDocPropertyTags?: readonly ts.JSDocPropertyLikeTag[] | undefined, isArrayType?: boolean | undefined): ts.JSDocTypeLiteral;
    updateJSDocTypeLiteral(node: ts.JSDocTypeLiteral, jsDocPropertyTags: readonly ts.JSDocPropertyLikeTag[] | undefined, isArrayType: boolean | undefined): ts.JSDocTypeLiteral;
    createJSDocSignature(typeParameters: readonly ts.JSDocTemplateTag[] | undefined, parameters: readonly ts.JSDocParameterTag[], type?: ts.JSDocReturnTag | undefined): ts.JSDocSignature;
    updateJSDocSignature(node: ts.JSDocSignature, typeParameters: readonly ts.JSDocTemplateTag[] | undefined, parameters: readonly ts.JSDocParameterTag[], type: ts.JSDocReturnTag | undefined): ts.JSDocSignature;
    createJSDocTemplateTag(tagName: ts.Identifier | undefined, constraint: ts.JSDocTypeExpression | undefined, typeParameters: readonly ts.TypeParameterDeclaration[], comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocTemplateTag;
    updateJSDocTemplateTag(node: ts.JSDocTemplateTag, tagName: ts.Identifier | undefined, constraint: ts.JSDocTypeExpression | undefined, typeParameters: readonly ts.TypeParameterDeclaration[], comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocTemplateTag;
    createJSDocTypedefTag(tagName: ts.Identifier | undefined, typeExpression?: ts.JSDocTypeExpression | ts.JSDocTypeLiteral | undefined, fullName?: ts.Identifier | ts.JSDocNamespaceDeclaration | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocTypedefTag;
    updateJSDocTypedefTag(node: ts.JSDocTypedefTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression | ts.JSDocTypeLiteral | undefined, fullName: ts.Identifier | ts.JSDocNamespaceDeclaration | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocTypedefTag;
    createJSDocParameterTag(tagName: ts.Identifier | undefined, name: ts.EntityName, isBracketed: boolean, typeExpression?: ts.JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocParameterTag;
    updateJSDocParameterTag(node: ts.JSDocParameterTag, tagName: ts.Identifier | undefined, name: ts.EntityName, isBracketed: boolean, typeExpression: ts.JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocParameterTag;
    createJSDocPropertyTag(tagName: ts.Identifier | undefined, name: ts.EntityName, isBracketed: boolean, typeExpression?: ts.JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocPropertyTag;
    updateJSDocPropertyTag(node: ts.JSDocPropertyTag, tagName: ts.Identifier | undefined, name: ts.EntityName, isBracketed: boolean, typeExpression: ts.JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocPropertyTag;
    createJSDocTypeTag(tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocTypeTag;
    updateJSDocTypeTag(node: ts.JSDocTypeTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocTypeTag;
    createJSDocSeeTag(tagName: ts.Identifier | undefined, nameExpression: ts.JSDocNameReference | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocSeeTag;
    updateJSDocSeeTag(node: ts.JSDocSeeTag, tagName: ts.Identifier | undefined, nameExpression: ts.JSDocNameReference | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocSeeTag;
    createJSDocReturnTag(tagName: ts.Identifier | undefined, typeExpression?: ts.JSDocTypeExpression | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocReturnTag;
    updateJSDocReturnTag(node: ts.JSDocReturnTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocReturnTag;
    createJSDocThisTag(tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocThisTag;
    updateJSDocThisTag(node: ts.JSDocThisTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocThisTag;
    createJSDocEnumTag(tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocEnumTag;
    updateJSDocEnumTag(node: ts.JSDocEnumTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocEnumTag;
    createJSDocCallbackTag(tagName: ts.Identifier | undefined, typeExpression: ts.JSDocSignature, fullName?: ts.Identifier | ts.JSDocNamespaceDeclaration | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocCallbackTag;
    updateJSDocCallbackTag(node: ts.JSDocCallbackTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocSignature, fullName: ts.Identifier | ts.JSDocNamespaceDeclaration | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocCallbackTag;
    createJSDocOverloadTag(tagName: ts.Identifier | undefined, typeExpression: ts.JSDocSignature, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocOverloadTag;
    updateJSDocOverloadTag(node: ts.JSDocOverloadTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocSignature, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocOverloadTag;
    createJSDocAugmentsTag(tagName: ts.Identifier | undefined, className: ts.ExpressionWithTypeArguments & {
        readonly expression: ts.Identifier | ts.PropertyAccessEntityNameExpression;
    }, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocAugmentsTag;
    updateJSDocAugmentsTag(node: ts.JSDocAugmentsTag, tagName: ts.Identifier | undefined, className: ts.ExpressionWithTypeArguments & {
        readonly expression: ts.Identifier | ts.PropertyAccessEntityNameExpression;
    }, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocAugmentsTag;
    createJSDocImplementsTag(tagName: ts.Identifier | undefined, className: ts.ExpressionWithTypeArguments & {
        readonly expression: ts.Identifier | ts.PropertyAccessEntityNameExpression;
    }, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocImplementsTag;
    updateJSDocImplementsTag(node: ts.JSDocImplementsTag, tagName: ts.Identifier | undefined, className: ts.ExpressionWithTypeArguments & {
        readonly expression: ts.Identifier | ts.PropertyAccessEntityNameExpression;
    }, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocImplementsTag;
    createJSDocAuthorTag(tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocAuthorTag;
    updateJSDocAuthorTag(node: ts.JSDocAuthorTag, tagName: ts.Identifier | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocAuthorTag;
    createJSDocClassTag(tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocClassTag;
    updateJSDocClassTag(node: ts.JSDocClassTag, tagName: ts.Identifier | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocClassTag;
    createJSDocPublicTag(tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocPublicTag;
    updateJSDocPublicTag(node: ts.JSDocPublicTag, tagName: ts.Identifier | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocPublicTag;
    createJSDocPrivateTag(tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocPrivateTag;
    updateJSDocPrivateTag(node: ts.JSDocPrivateTag, tagName: ts.Identifier | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocPrivateTag;
    createJSDocProtectedTag(tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocProtectedTag;
    updateJSDocProtectedTag(node: ts.JSDocProtectedTag, tagName: ts.Identifier | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocProtectedTag;
    createJSDocReadonlyTag(tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocReadonlyTag;
    updateJSDocReadonlyTag(node: ts.JSDocReadonlyTag, tagName: ts.Identifier | undefined, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocReadonlyTag;
    createJSDocUnknownTag(tagName: ts.Identifier, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocUnknownTag;
    updateJSDocUnknownTag(node: ts.JSDocUnknownTag, tagName: ts.Identifier, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocUnknownTag;
    createJSDocDeprecatedTag(tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocDeprecatedTag;
    updateJSDocDeprecatedTag(node: ts.JSDocDeprecatedTag, tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocDeprecatedTag;
    createJSDocOverrideTag(tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocOverrideTag;
    updateJSDocOverrideTag(node: ts.JSDocOverrideTag, tagName: ts.Identifier | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocOverrideTag;
    createJSDocThrowsTag(tagName: ts.Identifier, typeExpression: ts.JSDocTypeExpression | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocThrowsTag;
    updateJSDocThrowsTag(node: ts.JSDocThrowsTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression | undefined, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocThrowsTag;
    createJSDocSatisfiesTag(tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression, comment?: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocSatisfiesTag;
    updateJSDocSatisfiesTag(node: ts.JSDocSatisfiesTag, tagName: ts.Identifier | undefined, typeExpression: ts.JSDocTypeExpression, comment: string | ts.NodeArray<ts.JSDocComment> | undefined): ts.JSDocSatisfiesTag;
    createJSDocText(text: string): ts.JSDocText;
    updateJSDocText(node: ts.JSDocText, text: string): ts.JSDocText;
    createJSDocComment(comment?: string | ts.NodeArray<ts.JSDocComment> | undefined, tags?: readonly ts.JSDocTag[] | undefined): ts.JSDoc;
    updateJSDocComment(node: ts.JSDoc, comment: string | ts.NodeArray<ts.JSDocComment> | undefined, tags: readonly ts.JSDocTag[] | undefined): ts.JSDoc;
    createJsxElement(openingElement: ts.JsxOpeningElement, children: readonly ts.JsxChild[], closingElement: ts.JsxClosingElement): ts.JsxElement;
    updateJsxElement(node: ts.JsxElement, openingElement: ts.JsxOpeningElement, children: readonly ts.JsxChild[], closingElement: ts.JsxClosingElement): ts.JsxElement;
    createJsxSelfClosingElement(tagName: ts.JsxTagNameExpression, typeArguments: readonly ts.TypeNode[] | undefined, attributes: ts.JsxAttributes): ts.JsxSelfClosingElement;
    updateJsxSelfClosingElement(node: ts.JsxSelfClosingElement, tagName: ts.JsxTagNameExpression, typeArguments: readonly ts.TypeNode[] | undefined, attributes: ts.JsxAttributes): ts.JsxSelfClosingElement;
    createJsxOpeningElement(tagName: ts.JsxTagNameExpression, typeArguments: readonly ts.TypeNode[] | undefined, attributes: ts.JsxAttributes): ts.JsxOpeningElement;
    updateJsxOpeningElement(node: ts.JsxOpeningElement, tagName: ts.JsxTagNameExpression, typeArguments: readonly ts.TypeNode[] | undefined, attributes: ts.JsxAttributes): ts.JsxOpeningElement;
    createJsxClosingElement(tagName: ts.JsxTagNameExpression): ts.JsxClosingElement;
    updateJsxClosingElement(node: ts.JsxClosingElement, tagName: ts.JsxTagNameExpression): ts.JsxClosingElement;
    createJsxFragment(openingFragment: ts.JsxOpeningFragment, children: readonly ts.JsxChild[], closingFragment: ts.JsxClosingFragment): ts.JsxFragment;
    createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined): ts.JsxText;
    updateJsxText(node: ts.JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined): ts.JsxText;
    createJsxOpeningFragment(): ts.JsxOpeningFragment;
    createJsxJsxClosingFragment(): ts.JsxClosingFragment;
    updateJsxFragment(node: ts.JsxFragment, openingFragment: ts.JsxOpeningFragment, children: readonly ts.JsxChild[], closingFragment: ts.JsxClosingFragment): ts.JsxFragment;
    createJsxAttribute(name: ts.JsxAttributeName, initializer: ts.JsxAttributeValue | undefined): ts.JsxAttribute;
    updateJsxAttribute(node: ts.JsxAttribute, name: ts.JsxAttributeName, initializer: ts.JsxAttributeValue | undefined): ts.JsxAttribute;
    createJsxAttributes(properties: readonly ts.JsxAttributeLike[]): ts.JsxAttributes;
    updateJsxAttributes(node: ts.JsxAttributes, properties: readonly ts.JsxAttributeLike[]): ts.JsxAttributes;
    createJsxSpreadAttribute(expression: ts.Expression): ts.JsxSpreadAttribute;
    updateJsxSpreadAttribute(node: ts.JsxSpreadAttribute, expression: ts.Expression): ts.JsxSpreadAttribute;
    createJsxExpression(dotDotDotToken: ts.DotDotDotToken | undefined, expression: ts.Expression | undefined): ts.JsxExpression;
    updateJsxExpression(node: ts.JsxExpression, expression: ts.Expression | undefined): ts.JsxExpression;
    createJsxNamespacedName(namespace: ts.Identifier, name: ts.Identifier): ts.JsxNamespacedName;
    updateJsxNamespacedName(node: ts.JsxNamespacedName, namespace: ts.Identifier, name: ts.Identifier): ts.JsxNamespacedName;
    createCaseClause(expression: ts.Expression, statements: readonly ts.Statement[]): ts.CaseClause;
    updateCaseClause(node: ts.CaseClause, expression: ts.Expression, statements: readonly ts.Statement[]): ts.CaseClause;
    createDefaultClause(statements: readonly ts.Statement[]): ts.DefaultClause;
    updateDefaultClause(node: ts.DefaultClause, statements: readonly ts.Statement[]): ts.DefaultClause;
    createHeritageClause(token: ts.SyntaxKind.ExtendsKeyword | ts.SyntaxKind.ImplementsKeyword, types: readonly ts.ExpressionWithTypeArguments[]): ts.HeritageClause;
    updateHeritageClause(node: ts.HeritageClause, types: readonly ts.ExpressionWithTypeArguments[]): ts.HeritageClause;
    createCatchClause(variableDeclaration: string | ts.BindingName | ts.VariableDeclaration | undefined, block: ts.Block): ts.CatchClause;
    updateCatchClause(node: ts.CatchClause, variableDeclaration: ts.VariableDeclaration | undefined, block: ts.Block): ts.CatchClause;
    createPropertyAssignment(name: string | ts.PropertyName, initializer: ts.Expression): ts.PropertyAssignment;
    updatePropertyAssignment(node: ts.PropertyAssignment, name: ts.PropertyName, initializer: ts.Expression): ts.PropertyAssignment;
    createShorthandPropertyAssignment(name: string | ts.Identifier, objectAssignmentInitializer?: ts.Expression | undefined): ts.ShorthandPropertyAssignment;
    updateShorthandPropertyAssignment(node: ts.ShorthandPropertyAssignment, name: ts.Identifier, objectAssignmentInitializer: ts.Expression | undefined): ts.ShorthandPropertyAssignment;
    createSpreadAssignment(expression: ts.Expression): ts.SpreadAssignment;
    updateSpreadAssignment(node: ts.SpreadAssignment, expression: ts.Expression): ts.SpreadAssignment;
    createEnumMember(name: string | ts.PropertyName, initializer?: ts.Expression | undefined): ts.EnumMember;
    updateEnumMember(node: ts.EnumMember, name: ts.PropertyName, initializer: ts.Expression | undefined): ts.EnumMember;
    createSourceFile(statements: readonly ts.Statement[], endOfFileToken: ts.EndOfFileToken, flags: ts.NodeFlags): ts.SourceFile;
    updateSourceFile(node: ts.SourceFile, statements: readonly ts.Statement[], isDeclarationFile?: boolean | undefined, referencedFiles?: readonly ts.FileReference[] | undefined, typeReferences?: readonly ts.FileReference[] | undefined, hasNoDefaultLib?: boolean | undefined, libReferences?: readonly ts.FileReference[] | undefined): ts.SourceFile;
    createNotEmittedStatement(original: ts.Node): ts.NotEmittedStatement;
    createPartiallyEmittedExpression(expression: ts.Expression, original?: ts.Node | undefined): ts.PartiallyEmittedExpression;
    updatePartiallyEmittedExpression(node: ts.PartiallyEmittedExpression, expression: ts.Expression): ts.PartiallyEmittedExpression;
    createCommaListExpression(elements: readonly ts.Expression[]): ts.CommaListExpression;
    updateCommaListExpression(node: ts.CommaListExpression, elements: readonly ts.Expression[]): ts.CommaListExpression;
    createBundle(sourceFiles: readonly ts.SourceFile[]): ts.Bundle;
    createBundle(sourceFiles: readonly ts.SourceFile[], prepends?: readonly (ts.UnparsedSource | ts.InputFiles)[] | undefined): ts.Bundle;
    updateBundle(node: ts.Bundle, sourceFiles: readonly ts.SourceFile[]): ts.Bundle;
    updateBundle(node: ts.Bundle, sourceFiles: readonly ts.SourceFile[], prepends?: readonly (ts.UnparsedSource | ts.InputFiles)[] | undefined): ts.Bundle;
    createComma(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createAssignment(left: ts.ObjectLiteralExpression | ts.ArrayLiteralExpression, right: ts.Expression): ts.DestructuringAssignment;
    createAssignment(left: ts.Expression, right: ts.Expression): ts.AssignmentExpression<ts.EqualsToken>;
    createLogicalOr(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createLogicalAnd(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createBitwiseOr(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createBitwiseXor(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createBitwiseAnd(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createStrictEquality(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createStrictInequality(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createEquality(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createInequality(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createLessThan(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createLessThanEquals(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createGreaterThan(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createGreaterThanEquals(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createLeftShift(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createRightShift(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createUnsignedRightShift(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createAdd(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createSubtract(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createMultiply(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createDivide(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createModulo(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createExponent(left: ts.Expression, right: ts.Expression): ts.BinaryExpression;
    createPrefixPlus(operand: ts.Expression): ts.PrefixUnaryExpression;
    createPrefixMinus(operand: ts.Expression): ts.PrefixUnaryExpression;
    createPrefixIncrement(operand: ts.Expression): ts.PrefixUnaryExpression;
    createPrefixDecrement(operand: ts.Expression): ts.PrefixUnaryExpression;
    createBitwiseNot(operand: ts.Expression): ts.PrefixUnaryExpression;
    createLogicalNot(operand: ts.Expression): ts.PrefixUnaryExpression;
    createPostfixIncrement(operand: ts.Expression): ts.PostfixUnaryExpression;
    createPostfixDecrement(operand: ts.Expression): ts.PostfixUnaryExpression;
    createImmediatelyInvokedFunctionExpression(statements: readonly ts.Statement[]): ts.CallExpression;
    createImmediatelyInvokedFunctionExpression(statements: readonly ts.Statement[], param: ts.ParameterDeclaration, paramValue: ts.Expression): ts.CallExpression;
    createImmediatelyInvokedArrowFunction(statements: readonly ts.Statement[]): ts.ImmediatelyInvokedArrowFunction;
    createImmediatelyInvokedArrowFunction(statements: readonly ts.Statement[], param: ts.ParameterDeclaration, paramValue: ts.Expression): ts.ImmediatelyInvokedArrowFunction;
    createVoidZero(): ts.VoidExpression;
    createExportDefault(expression: ts.Expression): ts.ExportAssignment;
    createExternalModuleExport(exportName: ts.Identifier): ts.ExportDeclaration;
    restoreOuterExpressions(outerExpression: ts.Expression | undefined, innerExpression: ts.Expression, kinds?: ts.OuterExpressionKinds | undefined): ts.Expression;
};
export {};
